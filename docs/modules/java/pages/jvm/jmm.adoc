= Runtime Data Area

Runtime Data Area 是存放数据的，在逻辑上将内存划分为 线程栈（thread stacks）和堆内存 （heap）两个部分。 如下图所示：

[plantuml]
----
@startuml
skinparam componentStyle rectangle

package JVM {
package stack_1 {}
package stack_2 {}
package heap {
}
}
@enduml
----

****
总体来看，JVM 把内存划分为“栈(stack)”与“堆(heap)”两大类，为何要这样设计？

个人理解，程序运行时，内存中的信息大致分为两类，

* 一是跟程序执行逻辑相关的指令数据，这类数据通常不大，而且生命周期短；
* 一是跟对象实例相关的数据，这类数据可能会很大，而且可以被多个线程长时间内反复共用，比如字符串常量、缓存对象这类。
****

== 堆内存

堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问, 只要他们能拿到对象的引用地址。

如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。 如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。

* 堆
** 用来放置 Java 对象实例
** 堆是垃圾收集器重点照顾的区域
** 堆内空间还会被不同的垃圾收集器进行进一步的细分，如年轻代和老年代
*** 年轻代是大部分对象创建和销毁的区域
**** 分为新生代 `Eden` 区和两个存活区 `Survivor` 区（ `From Survivor`、`To Survivor`），比例 8:1:1
*** 老年代是放置长生命周期的对象或者对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代

* 非堆（aka 方法区、永久代、元空间）
** 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

== 线程栈

每个正在运行的线程，都有自己的线程栈。 线程栈包含了当前正在执行的方法链/调用链上的所有方法的状态信息 ，是线程私有。

* 程序计数器
** 当前线程所执行的字节码的行号指示器
* 虚拟机栈
** 内部保存一个个的栈帧(Stack Frame)，对应着一次次的 Java 方法调用。
** JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。
** 栈帧中存储着局部变量表、操作数(operand)栈、动态链接、方法正常退出或者异常退出的定义等。
* 本地方法栈
** 和 Java 虚拟机栈是非常相似的，支持对 本地方法的调用

== CPU指令乱序和内存屏障