= Q&A

== 年轻代为什么分三个区

.heap
[cols='3a,1a,1a,3']
|===
3+| 新生代 (1/3堆空间)
| 老生代 (2/3堆空间)
|
Eden (8/10)
|
From Survivor (1/10)
| To Survivor (1/10)
|
|===

* 降低老年代的内存分配压力,通过设置两个s区来对年轻对象进行拦截,降低fullGc的次数
* 分三代能使老年代作为担保来应付s区容不下存活对象的情况

回收基于 *标记-复制算法*

. 每个新对象先进入 `Eden`
. 第一次 MinorGC 存活的对象由 `Eden` 进入 `From Survivor`，清空 `Eden`
. 第二次 MinorGC 存活的对象由 `Eden`、`From Survivor` 进入 `To Survivor`，清空 `Eden`、`From Survivor`
. 第三次 MinorGC 存活的对象由 `Eden`、`To Survivor` 进入 `From Survivor`，清空 `Eden`、`To Survivor`
. 如此反复三四步直到对象年龄达标或者 `Survivor` 区容不下存活对象时晋升到老年代

== 年轻代三个区比例为什么是 8:1:1

深入理解虚拟机一书里有描述,IBM的一项研究,表明新生代中有98%的对象是朝生夕灭的,换言之,每次mionrGC后存活的对象应该小于等于2%，

所以看起来采用复制算法的新生代似乎可以不用将内存分成大小相等的两块了,但考虑到实验偏差以及实际情况的多样性,

jvm 默认预留了10%的内存用于存放存活对象,此时结合上文描述的,新生代最优应该分成三块,所以得再预留一块10%的内存给s区,那么自然剩下的80%就是e区的大小了；